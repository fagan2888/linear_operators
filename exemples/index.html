---
layout: default
title: linear_operators/exemples
---

<div id="home">
  <h1 id="intro">exemples</h1>
  <div>

    <h3> Quadratic deconvolution </h3>

    <p> The following exemple can be found
      <a href="https://github.com/nbarbey/linear_operators/blob/master/exemples/L2deconvolution.py">here</a>.
      It shows how simple it is using linear_operators to perform simple
      deconvolution using the conjugate gradient algorithm.</p>

    <p>The first line allows to call the script from the shell as an executable:
      <pre>#!/usr/bin/env python</pre>
    </p>

    <p> Then, you need to import the required Python packages:
      <pre>import numpy as np
import scipy
import linear_operators as lo
      </pre>
    </p>
    <p>
      Scipy is used in the script only to load an exemple image:
      <pre>im = scipy.lena() </pre>
      Using matplotlib, you could take a look at the image using
      imshow for instance.  Of course you need to import imshow from
      pylab if this is not already done.  If your are using IPython
      with the --pylab option, the imshow import have already been
      done for you :
      <pre>imshow(im)</pre>
      You would get this image :
    <p align="center" >
      <img src="lena.png" WIDTH="50%" HEIGHT="50%" /> 
    </p>
    </p>

    <p>
      Now, we start to use the linear_operator package to define a
      convolution operator:
      <pre>kernel = np.ones((3, 3))
model = lo.convolve_ndimage(im.shape, kernel)</pre>

      This defines a convolution with an uniform kernel of shape 3x3
      which is to be applied to an ndarray of the shape of the image.
    </p>
    <p>
      To perform the convolution on the image, simply call the operator:

      <pre>data = model(im)</pre>

      Alternatively, you can multiply the operator with the vectorized image:

      <pre>data = model * im.ravel()</pre>

      The ravel method is required here as LinearOperators can only be
      multiplied to vectors. If an 2d array is passed, it is assumed to
      be a matrix and the matmat method is called, which is probably not
      what you want.
    </p>

    <p>
      Adding noise to the data is quite simple thanks to numpy.random subpackage:
      <pre>noise = 1e1 * np.random.randn(*data.shape)
data += noise</pre>
      Taking a look at the image, you would get something like this:
    <p align="center" >
      <img src="convolved_lena.png" WIDTH="50%" HEIGHT="50%" /> 
    </p>
    See how the image is blurred as compared to the original image.
    </p>

    <p>Now that we have our exemple data, we want to try deconvolving
      the image knowing the kernel. For this, we make use of quadratic
      deconvolution using the conjugate gradient algorithm provided in
      linear_operators.  First, we need to define priors to regularize
      the inversion. Otherwise, the result would be way too noisy.
      <pre>prior = [lo.diff(im.shape, axis=i) for i in xrange(im.ndim)]
hypers = (1e1, 1e1)</pre>
      The hyperparameters "hypers" determines the importance to give to
      the priors relative to the likelihood. It is related to the amount
      of noise in the data.
    </p>

    <p>Finally, we instantiate and call the conjugate gradient
      algorithm:
      <pre>algo = lo.QuadraticConjugateGradient(model, data, prior, hypers)
xe = algo()
  </pre>
      The output need to be reshaped as an image as algorithms work
      only on vectors since the rely on the matvec method of LinearOperators
      <pre>xe.resize(im.shape)</pre>
    </p>
    <p>
      Now, you can take a look at the result:
    <p align="center" >
      <img src="deconvolved_lena.png" WIDTH="50%" HEIGHT="50%" /> 
    </p>
    This is not perfect as quadratic deconvolution is not the best
    algorithm to perform deconvolution. In particular you can see
    ripples close to the edges of the images.
    </p>
    <p>
      However this simple exemples illustrate how easy it is with the
      linear_operators package to set up a simple deconvolution script
      in about 15 lines of code.
    </p>


    <h3> Deconvolution with the double loop algorithm </h3>

    <p> The following exemple can be found
      <a href="https://github.com/nbarbey/linear_operators/blob/master/exemples/deconvolution_dli.py">
	in the exemples directory </a>.
      It illustrates the performances of an unsupervised algorithm derived in
      <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.165.8284&rep=rep1&type=pdf">
	Seeger et al. 2010 </a>.
      The algorithm itself is coded in
      <a href="https://github.com/nbarbey/linear_operators/blob/master/linear_operators/iterative/dli.py">
	iterative/dli.py </a>
    </p>

    For this exemple Lena has been convolved with an uniform kernel of
    ones of size 7 times 7. The original image has been downsampled by
    a factor 4 for speed. In addition, there is noise white noise
    added to the date too.

    <pre>
#!/usr/bin/env python
import numpy as np
import scipy
import linear_operators as lo

# Load the infamous Lena image from scipy
im = scipy.lena()
im = im[::4, ::4]
# Generate a convolution model with a 7x7 uniform kernel
model = lo.convolve_ndimage(im.shape, np.ones((7, 7)))
# convolve the original image
data = model * im.ravel()
# add noise to the convolved data
data += 1e0 * np.random.randn(*data.shape)
# define smoothness prior
</pre>

    The data looks very blurred :

    <p align="center" >
      <img src="dli_data.png" WIDTH="50%" HEIGHT="50%" />
    </p>

    Amazingly enough, the algorithm manages to get back most of the
    information.

    <p align="center" >
      <img src="dli_estimation.png" WIDTH="50%" HEIGHT="50%" />
    </p>

    The algorithm used for this exemple is quite complex but can be
    coded by plugging together off-the-shelf algorithms for sparse
    estimation and covariance approximation.

    As you can see, there is no ringing effect on the estimated image.
    This is a benefit from the underlying statistical model of the
    algorithm : automatic relevence determination, which is way better
    than the quadratic model for image deconvolution as it is closer
    to the true statistics of natural images.

  </div>
</div>
